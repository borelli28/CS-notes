CS162: Operating Systems and Systems Programming - UC Berkley, John Kubiatowicz


// Lecture 1 - Intro
Operating systems
	- Provide consistent abstractions to applications
	- Manage sharing of resources among multiple applications

	Building blocks:
		- Processes
		- Threads, Concurrency, Scheduling, Coordination
		- Address spaces
		- Protection, isolation, sharing, security
		- Communication, protocols
		- Persistent storage, transactions, consistency, resilience
		- Interfaces to all devices

	OS Basics:
		- Hardware:
			1) Processor
			2) Memory
			3) Storage
			4) Networks
		- OS:
			1) Threads
			2) Address spaces
			3) Files
			4) Sockets
		- Process: Execution environment wit restricted rights provided by the OS
		- Compiled program
			- System libraries

// Lecture 2
The OS abstracts underlying hardware to help tame complexity
	- Processor -> thread
	- Memory -> address space
	- Disks, SSDs -> files
	- Networks -> sockets
	- Machines -> processes

Four fundamental OS concepts
	- Thread: Execution context
		- Fully describes program state
		- Program counter, registers, execution flags, stack
	- Address space
		- Set of memory addresses accessible to program(for read/write)
		- May be distinct from memory space of the physical machine
	- Process: An instance of a running program
		- Protected address space
	- Dual mode operation/protection
		- Kernel mode, and user mode
		- Only the "system" has the ability to access certain resources
		- Combined with translation, isolates programs from each other and the OS from programs

Thread Control Block(TCB): Holds contents of registers when thread is not running. Use on multithreaded processes, during context switch

// Lecture 3 - Abstractions: Threads and Processes
Thread: A single unique execution context
	- Thread purpose: OS needs to handle multiple things at once(MTAO)
	- Threads are a unit of concurrency provided by the OS
	- Each thread can represent one thing or one task

Running threads concurrently: Scheduler(kernel) is free to run threads in any order, by breaking threads into chunks and running them in the most efficient way possible.

Thread states
	- RUNNING
	- READY: Elegible to run, but not currenly running
	- BLOCKED: Ineligible to run

pthreads: OS library API for threads(semi standarized for all OS'ses)
	- pthread_create: Creates a thread, and the returns is an implicit call to pthread_exit
	- pthread_exit: Terminates the thread
	- pthread_join: Suspends execution of the calling thread until the target thread terminates

Shared vs per-thread state
	- Shared state: State shared by every thread
		- Heap
		- Global variables
		- Code
	- Per-thread state: State unique for each thread
		- TCB: Thread control block
			- Stack information
			- Saved registers
			- Thread metadata
		- Stack: Stack holds temporary results, permits recursive execution(push each function on execution to stack)

pthreads lock
	- pthread_mutex_init: Initialize lock
	- pthread_mutex_lock: Grab a lock
	- pthread_mutex_unlock: Release the lock

Bootstrapping: Processes are created by other processes. The first process is created by the kernel and its called the "init" process.

Process management APIs
	- exit: terminate a process
	- fork: copy the current process
	- exec: change the program being run by the current process
	- wait: wait for a process to finish
	- kill: send a signal to another process
	- sigaction: set handlers for signals

// Lecture 4 - Files and I/O
Semaphore: A kind of generalized lock. A semaphore has a non-negative integer value and supports the following two operations:
	- P() or down(): Atomic operation that waits for semaphore to become positive, then decrements it by 1
	- V() or up(): Atomic operation that increments the semaphore by 1, waking up a waiting P, if any
	- Called a binary semaphore or mutex:
		inital value of semaphore = 1;
		semaphore.down();
			// Critical section of code here
		semaphore.up();

POSIX: Portable Operating System Interface(for uniX)
	- Interface for application programmers
	- Created to bring order to many Unix-derived OSes, so applications are portable

The file system abstraction
	- File
		- Named collection of data in a file system
		- POSIX file data: sequence of bytes
		- File metadata: size, modification time, owner, security info, access control
	- Directory
		- Folder containing files & directories
		- Hierarchical naming
			- /home/ff/cs162/index.html
		- Links and volumes

C High level file API - Streams: Unformatted sequences of bytes with a position(pointer)
	- stdin: Normal source of input
	- stdout: Normal source of output
	- stderr: Diagnostics and errors

Low level file I/O - The RAW system-call interface
	int open (const char * filename, int flags p, mode_t mode])
	int creat (const char * filename, mode_t mode)
	int close (int filedes)

	- Integer return from open() is a file descriptor
	- Operations on file descriptors:
		- Open system call created an open file description entry in the system-wide table of open files
		- Open file description object in the kernel represents an instance of an open file
		- User is given an integer instead of a pointer to the file description in the kernel for kernel security reasons.

Low level file API
	- Read data from open file using file descriptor: ssize_t read()
		- Reads up to maxsize bytes
		- returns bytes read, 0 => EOF, -1 => error
	- Write data to open file using file descriptor: ssize_t write()
		- returns number of bytes written
	- Reposition file offset within kernel: off_t lseek()

Low level I/O - Other operations
	- Operations specific to terminals, devices, networking, etc...
		- e.g., ioctl
	- Duplicating descriptors
		- int dup2(int old, int new);
		- int dup(int old);
	- Pipes - channel
		- int pipe(int pipefd[2]);
		- Write to pipefd[1] can be read from pipefd[0]
	- File locking
	- Memory-mapping files
	- Async I/O



	





